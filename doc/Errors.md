[README.md](../README.md)

# Errors and exception handling


## C#
An exception is a problem that arises during the execution of a program. A C# exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero. Exceptions provide a way to transfer control from one part of a program to another. C# exception handling is built upon four keywords: **try**, **catch**, **finally**, and **throw**.

### Syntax
Assuming a block raises an exception, a method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following −
```cs
try {
   // statements causing exception
} catch( ExceptionName e1 ) {
   // error handling code
} catch( ExceptionName e2 ) {
   // error handling code
} catch( ExceptionName eN ) {
   // error handling code
} finally {
   // statements to be executed
}
```
You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations.

### Exception Classes
C# exceptions are represented by classes. The exception classes in C# are mainly directly or indirectly derived from the **System.Exception** class. Some of the exception classes derived from the **System.Exception** class are the **System.ApplicationException** and **System.SystemException** classes.

The **System.ApplicationException** class supports exceptions generated by application programs. Hence the exceptions defined by the programmers should derive from this class.

The **System.SystemException** class is the base class for all predefined system exception.

### Handling Exceptions
C# provides a structured solution to the exception handling in the form of try and catch blocks. Using these blocks the core program statements are separated from the error-handling statements.
These error handling blocks are implemented using the try, catch, and finally keywords. Following is an example of throwing an exception when dividing by zero condition occurs −
```cs
using System;

namespace ErrorHandlingApplication {
   class DivNumbers {
      int result;
      
      DivNumbers() {
         result = 0;
      }
      public void division(int num1, int num2) {
         try {
            result = num1 / num2;
         } catch (DivideByZeroException e) {
            Console.WriteLine("Exception caught: {0}", e);
         } finally {
            Console.WriteLine("Result: {0}", result);
         }
      }
      static void Main(string[] args) {
         DivNumbers d = new DivNumbers();
         d.division(25, 0);
         Console.ReadKey();
      }
   }
}
```
When the above code is compiled and executed, it produces the following result −
```
Exception caught: System.DivideByZeroException: Attempted to divide by zero. 
at ...
Result: 0
```

### Creating User-Defined Exceptions
You can also define your own exception. User-defined exception classes are derived from the **Exception** class. The following example demonstrates this −
```cs
using System;

namespace UserDefinedException {
   class TestTemperature {
      static void Main(string[] args) {
         Temperature temp = new Temperature();
         try {
            temp.showTemp();
         } catch(TempIsZeroException e) {
            Console.WriteLine("TempIsZeroException: {0}", e.Message);
         }
         Console.ReadKey();
      }
   }
}
public class TempIsZeroException: Exception {
   public TempIsZeroException(string message): base(message) {
   }
}
public class Temperature {
   int temperature = 0;
   
   public void showTemp() {
      
      if(temperature == 0) {
         throw (new TempIsZeroException("Zero Temperature found"));
      } else {
         Console.WriteLine("Temperature: {0}", temperature);
      }
   }
}
```
When the above code is compiled and executed, it produces the following result −
```
TempIsZeroException: Zero Temperature found
```
### Throwing Objects
You can throw an object if it is either directly or indirectly derived from the **System.Exception** class. You can use a throw statement in the catch block to throw the present object as −
```cs
Catch(Exception e) {
   ...
   Throw e
}
```

Reference: [TutorialPoint](https://www.tutorialspoint.com/csharp/csharp_exception_handling.htm)

## Swift
In Swift, errors are represented by values of types that conform to the Error protocol.
This empty protocol indicates that a type can be used for error handling.
Swift enumerations are particularly well suited to modeling a group of related error conditions.

Here is an example enumerations
```Swift
enum ExampleError: Error {
    case Error1
    case Error2(someUsefulInformation: Int)
    case Error3
}
```
Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a *throw* statement to throw an error.

```Swift
throw ExampleError.Error2(someUsefulInformation: 3)
```

### Handling Errors
There are 4 ways in Swift to handle errors.
1. We can propagate the error from a function to the scope from which it is called.
2. wrapping the part which may throw errors with do-catch block.
3. handle the error as an optional value
4. assert that the error will not occur.

#### Propagating using Throwing
A function marked with throws is called a throwing function. If the function specifies a return type, you write the throws keyword before the return arrow (->).
A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.

```Swfit
func canThrowErrors() throws -> String

func cannotThrowErrors() -> String
```


#### Handling errors by Do-Catch
We use a do-catch statement to handle errors by running a block of code. If an error is thrown by the code in the do clause, it is matched against the catch clauses to determine which one of them can handle the error.

```Swfit
do {
    try expression
    statements
} catch pattern 1 {
    statements
} catch pattern 2 where condition {
    statements
}
```

#### Handling errors as an optional value
You use try? to handle an error by converting it to an optional value. If an error is thrown while evaluating the try? expression, the value of the expression is nil.

The below examples are doing the same thing.

##### Example1
```Swift
let x = try? someThrowingFunction()
```

```Swift
let x: Int?
do {
    x = try someThrowingFunction()
} catch {
    x = nil
}
```
The value of x will be nil if an exception occurs

#### Assert that an error will not occur (Disabling Error Propagation)

Sometimes we know a statement may cause an error but we know for sure it won't, we can use try! to do an assertion.

```Swift
let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
```

The above example uses the LoadImage function. We know sometimes the images may not exist so it may throw an imageNotFoundError
but we also know the images are inside the resources folder which indeed has the images we want, we can disable error propagation.

If any errors do occur during the runtime, we will get a runtime error and the application will be ceased.

### Cleanup actions
In Swift, we can use _**defer**_ to execute a set of statements just before code leaves the current scope. This is like
the finally block in Java where we may want to close the stream whether the code executed smoothly or an error was thrown.


